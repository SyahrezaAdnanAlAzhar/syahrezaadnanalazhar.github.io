---
// WebGLTopoBackground - Animated topographic contour lines using raw WebGL
// Uses simplex noise to generate infinite flowing contour lines
// Zero external dependencies — fullscreen shader quad rendered directly via WebGLRenderingContext
const base = import.meta.env.BASE_URL;
---

<div class="webgl-topo-container">
  <canvas id="topo-canvas"></canvas>
  <!-- Static fallback for browsers without WebGL -->
  <div id="topo-fallback" class="topo-fallback" style="display: none;">
    <img src={`${base}background/topo.svg`} alt="" aria-hidden="true" />
  </div>
</div>

<style>
  .webgl-topo-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
    background-color: #F5F2EB; /* Bone white background */
  }

  #topo-canvas {
    width: 100%;
    height: 100%;
    display: block;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
  }

  #topo-canvas.loaded {
    opacity: 1;
  }

  .topo-fallback {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .topo-fallback img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.3;
    filter: invert(1);
  }
</style>

<script>
  // ─── Raw WebGL helpers ────────────────────────────────────────────────

  /** Compile a single shader; returns null on failure. */
  function compileShader(
    gl: WebGLRenderingContext,
    type: number,
    source: string,
  ): WebGLShader | null {
    const shader = gl.createShader(type);
    if (!shader) return null;
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  /** Link a vertex + fragment shader into a program; returns null on failure. */
  function linkProgram(
    gl: WebGLRenderingContext,
    vertSrc: string,
    fragSrc: string,
  ): WebGLProgram | null {
    const vs = compileShader(gl, gl.VERTEX_SHADER, vertSrc);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fragSrc);
    if (!vs || !fs) return null;

    const program = gl.createProgram();
    if (!program) return null;
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    // Shaders can be freed after linking
    gl.deleteShader(vs);
    gl.deleteShader(fs);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  }

  // ─── Shader sources ───────────────────────────────────────────────────

  // Vertex shader — pass-through for a clip-space fullscreen quad
  const vertexShader = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  // Simplex noise function (runs entirely on GPU)
  const simplexNoise = `
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

    vec4 permute(vec4 x) { return mod289(((x*34.0)+10.0)*x); }

    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

    float snoise(vec3 v) { 
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

      vec3 i = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);

      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);

      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;

      i = mod289(i); 
      vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0)) +
        i.y + vec4(0.0, i1.y, i2.y, 1.0)) +
        i.x + vec4(0.0, i1.x, i2.x, 1.0));

      float n_ = 0.142857142857; 
      vec3 ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);

      vec4 x = x_ * ns.x + ns.yyyy;
      vec4 y = y_ * ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);

      vec4 s0 = floor(b0) * 2.0 + 1.0;
      vec4 s1 = floor(b1) * 2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

      vec3 p0 = vec3(a0.xy, h.x);
      vec3 p1 = vec3(a0.zw, h.y);
      vec3 p2 = vec3(a1.xy, h.z);
      vec3 p3 = vec3(a1.zw, h.w);

      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

      vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 105.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }
  `;

  // Fragment shader — creates contour lines from simplex noise
  const fragmentShader = `
    precision mediump float;

    uniform vec3 color;
    uniform float time;
    uniform vec2 resolution;

    ${simplexNoise}

    void main() {
      float levels = 6.0;

      // Scale coordinates — smaller value = larger, more spaced contours
      vec2 uv = gl_FragCoord.xy * 0.001;
      float noise = snoise(vec3(uv, time * 0.012));

      // Normalize noise from [-1, 1] to [0, 1]
      noise = (noise + 1.0) / 2.0;

      // Posterize — find which band we're in
      float lower = floor(noise * levels) / levels;
      float lowerDiff = noise - lower;

      // Only draw if we're at the edge of a band (creates contour lines)
      if (lowerDiff > 0.002)
        discard;

      gl_FragColor = vec4(color, 1.0);
    }
  `;

  // ─── Initialisation ───────────────────────────────────────────────────

  function initWebGLTopo() {
    const canvas = document.getElementById('topo-canvas') as HTMLCanvasElement;
    const fallback = document.getElementById('topo-fallback');
    if (!canvas) return;

    // Acquire WebGL context
    const gl = canvas.getContext('webgl', {
      alpha: true,
      antialias: false,
      powerPreference: 'low-power',
    });

    if (!gl) {
      console.warn('WebGL not supported, showing fallback');
      if (fallback) {
        fallback.style.display = 'block';
        canvas.style.display = 'none';
      }
      return;
    }

    // Compile & link shaders
    const program = linkProgram(gl, vertexShader, fragmentShader);
    if (!program) return;

    gl.useProgram(program);

    // ── Geometry: fullscreen quad (two triangles in clip space) ──────────
    const posAttr = gl.getAttribLocation(program, 'a_position');
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,   1, -1,  -1,  1,   // triangle 1
        -1,  1,   1, -1,   1,  1,   // triangle 2
      ]),
      gl.STATIC_DRAW,
    );
    gl.enableVertexAttribArray(posAttr);
    gl.vertexAttribPointer(posAttr, 2, gl.FLOAT, false, 0, 0);

    // ── Uniform locations ───────────────────────────────────────────────
    const uColor = gl.getUniformLocation(program, 'color');
    const uTime = gl.getUniformLocation(program, 'time');
    const uResolution = gl.getUniformLocation(program, 'resolution');

    // Line color: ash grey (#D4D4D4)
    gl.uniform3f(uColor, 212 / 255, 212 / 255, 212 / 255);

    // Clear color: bone white (#F9F6EE)
    gl.clearColor(249 / 255, 246 / 255, 238 / 255, 1.0);

    // ── Resize handler ──────────────────────────────────────────────────
    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      gl!.viewport(0, 0, canvas.width, canvas.height);
      gl!.uniform2f(uResolution, w, h);
    }
    resize();

    // Debounced resize
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resize, 100);
    });

    // ── Animation state ─────────────────────────────────────────────────
    let animationId: number;
    let isVisible = true;
    let frameCount = 0;
    let startTime = performance.now();

    const TIME_LOOP_DURATION = 120.0; // seconds before wrapping to avoid float precision loss
    const FRAME_SKIP = 2;             // render every 2nd frame

    // Pause when tab hidden for battery optimisation
    function handleVisibilityChange() {
      if (document.hidden) {
        isVisible = false;
      } else {
        isVisible = true;
        startTime = performance.now(); // reset to prevent time jump
        frameCount = 0;
      }
    }
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // ── Render loop ─────────────────────────────────────────────────────
    function animate() {
      animationId = requestAnimationFrame(animate);
      if (!isVisible) return;

      frameCount++;
      if (frameCount % FRAME_SKIP !== 0) return;

      const elapsed = (performance.now() - startTime) / 1000;
      gl!.uniform1f(uTime, elapsed % TIME_LOOP_DURATION);

      gl!.clear(gl!.COLOR_BUFFER_BIT);
      gl!.drawArrays(gl!.TRIANGLES, 0, 6);
    }
    animate();

    // Fade in the canvas after first render
    requestAnimationFrame(() => {
      canvas.classList.add('loaded');
    });

    // ── Cleanup on Astro page navigation ────────────────────────────────
    function cleanup() {
      cancelAnimationFrame(animationId);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      gl!.deleteBuffer(quadBuffer);
      gl!.deleteProgram(program);
    }
    document.addEventListener('astro:before-preparation', cleanup, { once: true });
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWebGLTopo);
  } else {
    initWebGLTopo();
  }

  // Re-initialize on Astro page navigation
  document.addEventListener('astro:page-load', initWebGLTopo);
</script>
