---
// WebGLTopoBackground - Animated topographic contour lines using Three.js
// Uses simplex noise to generate infinite flowing contour lines
const base = import.meta.env.BASE_URL;
---

<div class="webgl-topo-container">
  <canvas id="topo-canvas"></canvas>
  <!-- Static fallback for browsers without WebGL -->
  <div id="topo-fallback" class="topo-fallback" style="display: none;">
    <img src={`${base}background/topo.svg`} alt="" aria-hidden="true" />
  </div>
</div>

<style>
  .webgl-topo-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
    background-color: #F5F2EB; /* Bone white background */
  }

  #topo-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .topo-fallback {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .topo-fallback img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.3;
    filter: invert(1);
  }
</style>

<script>
  import * as THREE from 'three';

  // Shader code
  const vertexShader = `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  // Simplex noise function
  const simplexNoise = `
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

    vec4 permute(vec4 x) { return mod289(((x*34.0)+10.0)*x); }

    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

    float snoise(vec3 v) { 
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

      vec3 i = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);

      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);

      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;

      i = mod289(i); 
      vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0)) +
        i.y + vec4(0.0, i1.y, i2.y, 1.0)) +
        i.x + vec4(0.0, i1.x, i2.x, 1.0));

      float n_ = 0.142857142857; 
      vec3 ns = n_ * D.wyz - D.xzx;

      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);

      vec4 x = x_ * ns.x + ns.yyyy;
      vec4 y = y_ * ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);

      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);

      vec4 s0 = floor(b0) * 2.0 + 1.0;
      vec4 s1 = floor(b1) * 2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));

      vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

      vec3 p0 = vec3(a0.xy, h.x);
      vec3 p1 = vec3(a0.zw, h.y);
      vec3 p2 = vec3(a1.xy, h.z);
      vec3 p3 = vec3(a1.zw, h.w);

      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;

      vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 105.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }
  `;

  // Fragment shader - creates contour lines
  const fragmentShader = `
    uniform vec3 color;
    uniform float time;
    uniform vec2 resolution;

    void main() {
      float levels = 7.0; // Fewer contour lines (was 7, reduced for cleaner look)

      // Scale coordinates - smaller value = larger, more spaced contours
      vec2 uv = gl_FragCoord.xy * 0.001;
      float noise = snoise(vec3(uv, time * 0.012));
      
      // Normalize noise from [-1, 1] to [0, 1]
      noise = (noise + 1.0) / 2.0;

      // Posterize - find which band we're in
      float lower = floor(noise * levels) / levels;
      float lowerDiff = noise - lower;

      // Only draw if we're at the edge of a band (creates contour lines)
      // Smaller threshold = thinner lines (was 0.005, now 0.003)
      if (lowerDiff > 0.002)
        discard;

      gl_FragColor = vec4(color, 1.0);
    }
  `;

  function initWebGLTopo() {
    const canvas = document.getElementById('topo-canvas') as HTMLCanvasElement;
    const fallback = document.getElementById('topo-fallback');
    
    if (!canvas) return;

    // Check WebGL support
    let renderer: THREE.WebGLRenderer;
    try {
      renderer = new THREE.WebGLRenderer({ 
        canvas, 
        alpha: true,
        antialias: false, // Better performance
        powerPreference: 'low-power' // Battery optimization
      });
    } catch (e) {
      // WebGL not supported, show fallback
      console.warn('WebGL not supported, showing fallback');
      if (fallback) {
        fallback.style.display = 'block';
        canvas.style.display = 'none';
      }
      return;
    }

    // Setup
    const width = window.innerWidth;
    const height = window.innerHeight;
    const lineColor = 0xECECEC; // Ash grey

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(0, width, 0, height, 1, 2);
    camera.position.z = 2;

    renderer.setClearColor(0xF9F6EE, 1); // Bone white background
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance

    const clock = new THREE.Clock();

    // Create plane geometry
    const geometry = new THREE.PlaneGeometry(width, height);
    geometry.translate(width / 2, height / 2, 0);

    // Create shader material
    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(lineColor) },
        time: { value: 0 },
        resolution: { value: new THREE.Vector2(width, height) }
      },
      vertexShader: vertexShader,
      fragmentShader: simplexNoise + fragmentShader,
      side: THREE.BackSide,
      transparent: true
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Animation state
    let animationId: number;
    let isVisible = true;
    let frameCount = 0;
    
    // Performance optimization constants
    const TIME_LOOP_DURATION = 120.0; // Reset time every 120 seconds to prevent floating-point precision loss
    const FRAME_SKIP = 2; // Render every 2nd frame (set to 1 to disable skipping)

    // Visibility change handler for battery optimization
    function handleVisibilityChange() {
      if (document.hidden) {
        isVisible = false;
      } else {
        isVisible = true;
        clock.start(); // Reset clock to prevent time jump
        frameCount = 0; // Reset frame counter
      }
    }
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Handle resize
    function handleResize() {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      camera.right = newWidth;
      camera.bottom = newHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(newWidth, newHeight);
      material.uniforms.resolution.value.set(newWidth, newHeight);

      // Update geometry
      mesh.geometry.dispose();
      const newGeometry = new THREE.PlaneGeometry(newWidth, newHeight);
      newGeometry.translate(newWidth / 2, newHeight / 2, 0);
      mesh.geometry = newGeometry;
    }

    // Debounced resize
    let resizeTimeout: NodeJS.Timeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(handleResize, 100);
    });

    // Animation loop
    function animate() {
      animationId = requestAnimationFrame(animate);

      // Skip rendering if tab is not visible
      if (!isVisible) return;

      // Frame skipping for performance (render every Nth frame)
      frameCount++;
      if (frameCount % FRAME_SKIP !== 0) return;

      // Use modulo time to prevent floating-point precision loss after long sessions
      // This creates a seamless loop since the noise pattern is continuous
      const elapsedTime = clock.getElapsedTime();
      material.uniforms.time.value = elapsedTime % TIME_LOOP_DURATION;
      
      renderer.render(scene, camera);
    }
    animate();

    // Cleanup on page navigation (for Astro)
    function cleanup() {
      cancelAnimationFrame(animationId);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    }

    // Listen for Astro navigation
    document.addEventListener('astro:before-preparation', cleanup, { once: true });
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWebGLTopo);
  } else {
    initWebGLTopo();
  }

  // Re-initialize on Astro page navigation
  document.addEventListener('astro:page-load', initWebGLTopo);
</script>
